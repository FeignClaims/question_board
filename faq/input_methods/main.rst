.. _input_methods:

************************************************************************************************************************
几种 :cpp:`cin` 输入方式的区别
************************************************************************************************************************

为了描述方便, 用语约定如下:

读入
  从输入流中提取并使用内容, 输入流中将不再有该内容, 而该内容被实际使用.

读过
  从输入流中提取并忽略内容, 输入流中将不再有该内容, 而该内容被忽略.

查看
  查看输入流中内容, 输入流中内容不变.

.. admonition:: 输入流

  通常输入区域就像管道里的水流一样, 你只能首先接触最开始的字符, 且没有回头路.

========================================================================================================================
共同部分
========================================================================================================================

无论以下何种方式, 都会在到达文件尾 (eof, end of file) 时结束输入.

除 :cpp:`ch = cin.get()` 和 :cpp:`ch = cin.peek()`, 以下方式均返回输入流 :cpp:`cin` 本身, 从而允许链式调用和条件判断:

.. code-block:: cpp
  :linenos:
  :caption: 链式调用

  std::cin >> value1 >> value2;
  getline(getline(std::cin, line), line);

.. code-block:: cpp
  :linenos:
  :caption: 条件判断: :cpp:`cin` 能够隐式类型转换为 :cpp:`bool` 类型, 相当于表达式 :cpp:`!cin.fail()`.

  while (std::cin >> value) {
    /* 读取成功 */
  }


输入存在缓冲区, 当我们通过键盘或其他方式进行输入时, 程序总是将内容先填入对应的缓冲区中. :cpp:`cin` 即从它的缓冲区中读取要求的内容:

.. code-block:: cpp
  :linenos:
  :caption: 用键盘一次性输入若干内容

  // 直接输入: 1 2 3
  for (int value = 0; std::cin >> value;) {
    /* 第 1 次: value == 1 */
    /* 第 2 次: value == 2 */
    /* 第 3 次: value == 3 */
  }

.. hint::

  你也可以通过断点调试观察这个过程, 自己验证一下结果如何. 断点调试非常有用, 请学习 :doc:`/debugger/main` 并完成习题.

========================================================================================================================
格式化输入
========================================================================================================================

该方式输入的字符将会格式化为对应的类型值, 例如:

.. code-block:: cpp
  :linenos:

  int value;
  std::cin >> value;  // 读入的字符格式化为 int 类型值

:cpp:`cin >> value`
  默认情况下读过前面所有空白符, 然后读入字符直到查看到空白符.

========================================================================================================================
非格式化输入
========================================================================================================================

该方式输入的就是字符本身.

:cpp:`cin.get(ch);`、:cpp:`ch = cin.get();`
  读入输入流中第一个字符.

:cpp:`ch = cin.peek();`
  查看输入流中第一个字符.

:cpp:`cin.get(char* output, streamsize count, char delim = '\\n')`
  读入字符到 :cpp:`output` 中, 直到读入了 :cpp:`count - 1` 个字符或查看到分隔符 :cpp:`delim` (默认为换行符 :cpp:`'\\n'`); 若确实有读入字符, 则在之后附上终止字符 :cpp:'\\0'.

:cpp:`cin.getline(char* output, streamsize count, char delim = '\\n')`
  读入字符到 :cpp:`output` 中, 直到读入了 :cpp:`count - 1` 个字符或读过了分隔符 :cpp:`delim`; 若确实有读入字符, 则在之后附上终止字符 :cpp:'\\0'.

.. hint::

  为什么是读入 :cpp:`count - 1` 个字符? 因为这些输入方式认为输入内容将被作为一个字符串, 而字符串需要在尾部用 :cpp:`'\\0'` 表示终止, 故这些方式为 :cpp:`'\\0'` 预留一个位置.

:cpp:`getline(std::cin, std::string& output, char delim = '\\n')`
  读入字符到 :cpp:`output` 中, 直到读过了分隔符 :cpp:`delim`. 相比于上面的, 这是 **推荐的方式**.

:cpp:`cin.ignore(streamsize count, char delim)`
  读过字符直到读过了 :cpp:`count` 个字符或读过了分隔符 :cpp:`delim`.
  
  通常 :cpp:`#include <limits>`, 然后以 :cpp:`std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n')` 方式使用, 表示一直读过字符直到读过换行符 :cpp:`'\\n'`.

  此外, 你也可以使用 :cpp:`std::cin >> std::ws`, 这会读过所有的空白符 (空格、制表、换行等), 直到查看到非空白符.

:cpp:`cin.read(char* output, streamsize count)`
  读入 :cpp:`count` 个字符到 :cpp:`output` 中, 通常用于 :doc:`/faq/binary_io/main`.

========================================================================================================================
放回输入流中
========================================================================================================================

:cpp:`cin.unget()`
  将最近读入/读过的字符放回 :cpp:`cin` 中, 相当于 :cpp:`cin.get()` 的逆向操作.

:cpp:`cin.putback(char ch)`
  将 :cpp:`ch` 放回 :cpp:`cin` 中, 之后通过 :cpp:`cin` 进行输入时, 第一个字符将会是 :cpp:`ch`.

========================================================================================================================
最佳实践
========================================================================================================================

由于格式化输入和非格式化输入间的行为差异, **不建议混用格式化输入和非格式化输入**.

如果确实需要一行行读取内容, 并在行内进行格式化输入, 可以参考以下代码:

.. literalinclude:: main.cpp
  :language: cpp
  :linenos:
