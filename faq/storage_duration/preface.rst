************************************************************************************************************************
题目中所使用的类
************************************************************************************************************************

为了提高可读性, 部分地方采用了 C++20 的语法进行初始化, 见下文.

.. code-block:: text
  :linenos:

  ctor:        非拷贝构造时输出的字符
  copy_ctor:   拷贝构造时输出的字符
  copy_assign: 拷贝赋值时输出的字符
  dtor:        析构时输出的字符

========================================================================================================================
:cpp:`class Printer`
========================================================================================================================

在非拷贝构造, 被用于拷贝构造, 被用于拷贝赋值, 析构时输出对应的字符串.

例如,

.. code-block:: cpp
  :caption: 构造析构

  auto main() -> int {
    // 构造时输出 "0", 被用于拷贝构造时输出 "1", 被用于拷贝赋值时输出 "2", 析构时输出 "3", 其余情况不输出
    Printer c1{Info{.ctor = "0", .copy_ctor = "1", .copy_assign = "2", .dtor = "3"}};

    // 构造时输出 "4", 析构时输出 "5", 其余情况不输出
    Printer c2{Info{.ctor = "4", .dtor = "5"}};
  }
  // 最终输出
  // 0: c1 构造
  // 4: c2 构造
  // 5: c2 析构
  // 3: c1 析构

.. code-block:: cpp
  :caption: 拷贝构造

  auto main() -> int {
    // 构造时输出 "0", 被用于拷贝构造时输出 "1", 被用于拷贝赋值时输出 "2", 析构时输出 "3", 其余情况不输出
    Printer c1{Info{.ctor = "0", .copy_ctor = "1", .copy_assign = "2", .dtor = "3"}};

    // 拷贝构造输出 "1", 并且之后 c2.info == c1.info
    // 即此后构造时输出 "0", 被用于拷贝构造时输出 "1", 被用于拷贝赋值时输出 "2", 析构时输出 "3", 其余情况不输出
    Printer c2{c1};
  }
  // 最终输出
  // 0: c1 构造
  // 1: Printer c2{c1}
  // 3: c2 析构
  // 3: c1 析构

.. code-block:: cpp
  :caption: 拷贝赋值

  auto main() -> int {
    // 构造时输出 "0", 被用于拷贝构造时输出 "1", 被用于拷贝赋值时输出 "2", 析构时输出 "3", 其余情况不输出
    Printer c1{Info{.ctor = "0", .copy_ctor = "1", .copy_assign = "2", .dtor = "3"}};

    // 构造时输出 "4", 被用于拷贝构造时输出 "5", 被用于拷贝赋值时输出 "6", 析构时输出 "7", 其余情况不输出
    Printer c2{Info{.ctor = "4", .copy_ctor = "5", .copy_assign = "6", .dtor = "7"}};

    // 输出 "2", 并且之后 c2.info == c1.info
    // 即此后构造时输出 "0", 被用于拷贝构造时输出 "1", 被用于拷贝赋值时输出 "2", 析构时输出 "3", 其余情况不输出
    c2 = c1;
  }
  // 最终输出
  // 0: c1 构造
  // 4: c2 构造
  // 2: c2 = c1;
  // 3: c2 析构
  // 3: c1 析构

========================================================================================================================
:cpp:`class DerivedPrinter : public Printer`
========================================================================================================================

继承自 :cpp:`Printer`, 遵循继承的逻辑,

- 构造/赋值时先构造/赋值 :cpp:`Printer`, 再构造/赋值 :cpp:`DerivedPrinter`.
- 析构时先析构 :cpp:`DerivedPrinter`, 再析构 :cpp:`Printer`.
- 拷贝时发生切片, 只拷贝静态类型部分, 这部分内容可参考 :doc:`虚函数调用的感性理解 </faq/virtual_function_invocation_explain/main>`, 但注意那是逻辑上的感性解释.

.. code-block:: cpp
  :linenos:

  auto main() -> int {
    // 构造时输出 "03", 正常被用于拷贝时输出 "14", 析构时输出 "52", 其余情况不输出
    DerivedPrinter c1{Info{.ctor = "0", .copy_ctor = "1", .dtor = "2"},
                      DerivedInfo{.ctor = "3", .copy_ctor = "4", .dtor = "5"}};

    // 拷贝时发生切片, 仅拷贝了此处的静态类型, 即 `Printer` 部分
    //   最终仅得到 Info{.ctor = "0", .copy_ctor = "1", .dtor = "2"} 部分
    // 输出 "1", 并且之后 c2.info == c1.info
    // 即此后构造时输出 "0", 被用于拷贝构造时输出 "1", 析构时输出 "2", 其余情况不输出
    Printer c2 = c1;
  }
  // 最终输出
  // 0: c1 Printer 部分构造
  // 3: c1 DerivedPrinter 部分构造
  // 1: Printer c2 = c1; 发生切片, 仅拷贝 Printer 部分
  // 2: c2 析构
  // 5: c1 DerivedPrinter 部分析构
  // 2: c1 Printer 部分析构
