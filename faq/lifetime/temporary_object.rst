************************************************************************************************************************
5. 临时对象 (temporary object)
************************************************************************************************************************

========================================================================================================================
说明
========================================================================================================================

要正确而全面分析临时对象过于复杂了,  **它非常容易被优化** (:godbolt:`一个被优化的示例 <GzjcsW1sj>`).

故此处针对考试进行了简化, 仅涉及两种情况 (**不考虑任何优化 (返回值优化, 未使用值优化等)!**).

------------------------------------------------------------------------------------------------------------------------
未被延长的临时对象
------------------------------------------------------------------------------------------------------------------------

对于临时对象, 它在 **整个表达式 (完整表达式, full expression)** 结束时被销毁. 如果整个表达式中有多个临时对象, 那么按临时对象构造的相反顺序被销毁.

.. code-block:: cpp
  :linenos:

  Printer make_printer(Info info) {
    return Printer(info);
  }

  int main() {
    Printer c1{Info{.ctor = "0", .dtor = "1"}};
    make_printer(Info{.ctor = "2", .dtor = "3"}), make_printer(Info{.ctor = "4", .dtor = "5"});
    Printer c2{Info{.ctor = "6", .dtor = "7"}};
  }
  // 0: c1 构造
  // 2: 临时对象构造
  // 4: 临时对象构造
  // 5: 临时对象析构
  // 3: 临时对象析构
  // 6: c2 构造
  // 7: c2 析构
  // 1: c1 析构

------------------------------------------------------------------------------------------------------------------------
被延长的临时对象
------------------------------------------------------------------------------------------------------------------------

通过 :cpp:`const&` 可以延长临时对象的生命期, 则它的生命期在 :cpp:`const&` 的生命期结束时结束.

.. code-block:: cpp
  :linenos:

  Printer make_printer(Info info) {
    return Printer(info);
  }

  int main() {
    Printer c1{Info{.ctor = "0", .dtor = "1"}};
    Printer const& c2 = make_printer(Info{.ctor = "2", .dtor = "3"});
    { static Printer const& c3 = make_printer(Info{.ctor = "4", .dtor = "5"}); }
  }
  // 0: c1 构造
  // 2: c2 构造
  // 4: c3 构造
  // 3: c2 析构
  // 1: c1 析构
  // 5: c3 析构

========================================================================================================================
题目
========================================================================================================================

------------------------------------------------------------------------------------------------------------------------
题 1
------------------------------------------------------------------------------------------------------------------------

.. code-block:: cpp
  :linenos:

  int main() {
    make_printer(Info{.ctor = "m", .dtor = "i"});

    DerivedPrinter c1{
        Info{.ctor = "c", .copy_ctor = "o", .copy_assign = "u", .dtor = "s"},
        DerivedInfo{
            .ctor = "r", .copy_ctor = "h", .copy_assign = "a", .dtor = "d"}};

    static_cast<Printer*>(&c1);
    static_cast<Printer>(c1);

    Printer{Info{.ctor = "e", .dtor = "c"}};  // 这是临时对象
                                              // 所以平时写代码时不要漏写名字, 除非这就是想要的

    static_cast<Printer&>(c1);

    make_printer(Info{.ctor = "o", .dtor = "n"});
  }

.. admonition:: 点击查看提示
  :class: dropdown
  
  12 个字符, 一种时间单位.

  大多数情况下, :cpp:`static_cast<new_type>(expression)` 相当于以 :cpp:`new_type temp(expression);` 初始化了一个虚拟变量 :cpp:`temp`, 见于 :doc:`/faq/basic_concepts/type_conversion`.

.. admonition:: 点击查看答案
  :class: dropdown, solution

  :godbolt:`65jMzEePz`, 答案: :cpp:`microseconds`.

------------------------------------------------------------------------------------------------------------------------
题 2
------------------------------------------------------------------------------------------------------------------------

.. code-block:: cpp
  :linenos:

  int main() {
    Printer c1{
        Info{.ctor = "v", .copy_ctor = "d", .copy_assign = "u", .dtor = ">"}};
    Printer c2{Info{.ctor = "e", .dtor = "l"}};
    {
      {
        Printer c1{
            Info{.ctor = "c", .copy_ctor = "b", .copy_assign = "a", .dtor = "o"}};
        Printer{Info{.ctor = "t", .dtor = "o"}};
        { Printer c2{Info{.ctor = "r", .dtor = "<"}}; }
        Printer{c1};
      }
    }
  }

.. admonition:: 点击查看提示
  :class: dropdown
  
  12 个字符, :cpp:`std::vector<T>` 的特化版本, 但不是 STL 容器, 证明了代理对象和 STL 容器不可兼得的失败产物, 且在 C++23 之前不该用于 STL 算法.

.. admonition:: 点击查看答案
  :class: dropdown, solution

  :godbolt:`EhzbfoPfv`, 答案: :cpp:`vector<bool>`.

  注意考试中如果想用 STL 算法, 则不能用 :cpp:`vector<bool>`, 可以用 :cpp:`deque<bool>` 等其他 STL 容器代替.
