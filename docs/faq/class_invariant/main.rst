************************************************************************************************************************
不变式: 类和结构体的区别 (class invariant)
************************************************************************************************************************

类 (:cpp:`class`) 和结构体 (:cpp:`struct`) 到底有什么区别? 

从语法上, 它们没有区别, 写 :cpp:`struct Widget` 或者 :cpp:`class Widget` 都是自定义了类型 :cpp:`Widget`.

那么为什么要专门分成两个关键词呢? 这就要引入 C++ 的一个核心概念, **类的不变式 (class invariant)**.

========================================================================================================================
示例: 最简分式
========================================================================================================================

`C++ Core Guidelines`_ 将不变式定义为 "程序某一时刻或某一段时间里必须得到满足的条件", 对于类而言, 就是 **类的数据成员自己和之间的逻辑关系**.

例如我们打算实现最简分式类, 则根据最简分式的数学定义, 可以将分子、分母作为数据成员, 并且分子分母应该满足下列关系:

- 分子和分母之间不应该具有除 1 以外的公因数.
- 分母不为 0.

------------------------------------------------------------------------------------------------------------------------
最简分式结构体
------------------------------------------------------------------------------------------------------------------------

假如我们将该类型作为一个结构体, 按照结构体的习惯, 将分子分母作为公用 (:cpp:`public`) 数据成员, 可以简单地实现为以下代码:

.. code-block:: cpp
  :linenos:

  struct Lowest_terms_fraction {
   public:
    int numerator;    // 分子
    int denominator;  // 分母
  };

完成了!

可是, 如何保证使用者不破坏 "最简分式" 的定义? 他可以对数据成员做任何事!

.. code-block:: cpp
  :linenos:

  int main() {
    Lowest_terms_fraction fraction1 = {1, 3};  // 1/3, 是最简分式
    fraction1.numerator             = 3;       // 3/3, 分子和分母之间有公因数 3, 这不是最简分式!
    fraction1.denominator           = 0;       // 3/0, 分母为 0, 这不是最简分式!

    Lowest_terms_fraction fraction2 = {3, 3};  // 3/3, 从构造起就不是最简分式了!
  }

使用者为什么要破坏我们的最简分式? 因为我们让分子分母是公用数据成员, 而公用就是开放给他们任意使用的.

------------------------------------------------------------------------------------------------------------------------
阻止使用者破坏最简分式
------------------------------------------------------------------------------------------------------------------------

上面的例子中, 使用者有两处地方可以破坏我们的最简分式:

- 对象构造时: :cpp:`Lowest_terms_fraction fraction2 = {3, 3};`. 这意味着我们应该限制如何构造对象——我们应该定义构造函数.
- 对象使用时: :cpp:`fraction1.numerator = 3;`. 这意味着我们应该限制如何使用对象——我们应该将数据设为私用成员 (:cpp:`private`), 用公用成员函数告知使用者应该怎么访问.

即,

.. literalinclude:: class.cpp
  :language: cpp
  :linenos:

------------------------------------------------------------------------------------------------------------------------
最简分式类
------------------------------------------------------------------------------------------------------------------------

C++ 因此特意引入了新的关键字 :cpp:`class`, 当使用关键字 :cpp:`class`, 我们就是在告诉未来的代码读者 (可能是别人, 也可能是你自己) 这个类具有不变式.

因为类存在不变式, 才有了构造函数、拷贝构造/赋值函数、析构函数, 才有了公用、私用等访问说明, 才有了成员函数…… **理解了类的不变式, 就能据此推导理解类的其他特性**.

========================================================================================================================
最佳实践
========================================================================================================================

如果类具有不变式, 则使用 :cpp:`class`; 如果数据成员相互独立, 则使用 :cpp:`struct`. 即,

- 要么 :cpp:`class` + 构造函数 (+ 私用数据成员).
- 要么 :cpp:`struct` + 无构造函数 (+ 公用数据成员).

.. admonition:: 相关核心准则

  :doc:`/faq/coreguidelines/c_2`
  :doc:`/faq/coreguidelines/c_40`

========================================================================================================================
一个教学的黑点
========================================================================================================================

教学里完全没有不变式这个知识点: "这是类的语法, 这是我们怎么定义构造函数, 这是我们怎么定义成员函数, 这是公用私用的区别……", 但从来不会解释为什么要有这些.